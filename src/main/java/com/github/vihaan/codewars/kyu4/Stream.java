package com.github.vihaan.codewars.kyu4;

import java.util.List;
import java.util.LinkedList;
import java.util.Iterator;

import java.util.function.Function;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;

import java.lang.RuntimeException;

import stream.Thunk;

/*
Infinite sequences are common, natural numbers for example are defined such that they always have a successor. In Haskell, most of the time lists are used to model infinite sequences, but why should we check for the empty case, if it will never occur?

Streams offer an elegant alternative to model infinite data. A stream has a head element and an infinite tail, in lazy languages this is no problem, since the tail gets only evaluated when needed. But in languages with strict evaluation we need a lambda function to delay evaluation.

    Unevaluated expressions in Haskell are called thunks. They are
    evaluated when needed, and all shared references then point to
    the evaluated data.

    In the Java version we use the Thunk class. This enables lazy sharing,
    through modification of the Thunk. Note that even though the usage of
    Thunk in itself is impure, the usage is pure as long as the passed Supplier
    is pure. (That is: The value generated by the supplier is always the same.)

    Basic usage of Thunk:

// create from a value
Thunk<Integer> lazyA = Thunk.now(42);

// nothing is evaluated here
        int a = lazyA.get();

// create from a supplier
        Thunk<Integer> lazyB = Thunk.delay(() -> 21);

// create a new lazy computation with a function (the type of the thunk can change!)
        Thunk<Integer> lazyC = lazyB.chain(x -> x * 2);

// evaluates lazyB and then lazyC
        int c1 = lazyC.get();

// everything already evaluated here, since lazyC is shared!
        int c2 = lazyC.get();
        In pure functional code data is not mutated. Every reference is immutable. Calling a function won't change any state and should always return the same value.

        Basics
        Write headS which returns the value at the head of the stream and tailS which drops the first value of the stream.

        Let the streams flow!
        Implement functions to construct streams:

        repeatS will repeat the same value over and over again.
        iterateS will repeatedly apply the same function to the result of the last iteration (starting with a given value).
        cycleS will repeat a list forever.
        fromS will count numbers upwards by one.
        fromStepS will count numbers with a given step width.
        Modifying and reducing streams
        To work with streams, we always have to write a computation which ends in finite time, therefore we can only inspect a finite part of the stream. Implement common functions:

        foldrS folds a stream with a function from the left (The resulting structure can also be infinite!).
        filterS picks only those values, which satisfy the predicate.
        takeS takes a given number of elements from the stream.
        dropS drops a given number of elements from the stream. (Hint: Make sure to handle negative values.)
        Haskell only: splitAtS does take and drop at the same time.
        zipWithS merges 2 streams, by applying a function to each pair of values.
        Implement fmap, which maps every value of a stream with a function.
        Haskell only: Write an instance of Applicative for streams (type signatures are provided, in case you don't know what that means).
        To infinity and beyond
        With the written combinators, we can already do very useful things, for example we can write functions without relying on the unsafe head and tail functions for lists.

        Write streams for the following sequences:

        fibS is the stream of all fibonacci numbers (starting with 0).
        primeS is the stream of all prime numbers.
        Hint: The obvious definition of primeS would be with filterS and an isPrime predicate, while this sounds simple, it is not the most efficient solution (since it has to brute-force all numbers up to the given number). Figure out a way to reduce the amount of numbers to test in every step!


        */
public class Stream<T> {

    // head of the stream
    private T _head;

    // lazy tail of the stream
    private Thunk<Stream<T>> _tail;

    public Stream(T head, Thunk<Stream<T>> tail) {
        this._head = head;
        this._tail = tail;
    }

    // Returns the head of the stream.
    public T headS() {
        return _head;
    }

    // Returns the unevaluated tail of the stream.
    public Thunk<Stream<T>> tailS() {
        return _tail;
    }

    // Returns the evaluated tail of the stream.
    public Stream<T> next() {
        // not yet implemented
        return null;
    }

    // .------------------------------.
    // | Static constructor functions |
    // '------------------------------'

    // Construct a stream by repeating a value.
    public static <U> Stream<U> repeatS(U x) {
        // not yet implemented
        return null;
    }

    // Construct a stream by repeatedly applying a function.
    public static <U> Stream<U> iterateS(Function<U, U> f, U x) {
        // not yet implemented
        return null;
    }

    // Construct a stream by repeating a list forever. (Sadly no pure single linked lists :( )
    public static <U> Stream<U> cycleS(List<U> l) {
        // not yet implemented
        return null;
    }

    // Construct a stream by counting numbers starting from a given one.
    public static Stream<Integer> fromS(int x) {
        // not yet implemented
        return null;
    }

    // Same as @{fromS} but count with a given step width.
    public static Stream<Integer> fromThenS(int x, int d) {
        // not yet implemented
        return null;
    }

    // .------------------------------------------.
    // | Stream reduction and modification (pure) |
    // '------------------------------------------'

    // Fold a stream from the left.
    public <R> R foldrS(BiFunction<T, Thunk<R>, R> f) {
        // not yet implemented
        return null;
    }

    // Filter stream with a predicate. (Returns a lazy result.)
    public Thunk<Stream<T>> filterS(Predicate<T> p) {
        // not yet implemented
        return null;
    }

    // Take a given amount of elements from the stream.
    public LinkedList<T> takeS(int n) {
        // not yet implemented
        return null;
    }

    // Drop a given amount of elements from the stream.
    public Stream<T> dropS(int n) {
        // not yet implemented
        return null;
    }

    // Combine 2 streams with a function.
    public <U, R> Stream<R> zipWithS(BiFunction<T, U, R> f, Stream<U> other) {
        // not yet implemented
        return null;
    }

    // Map every value of the stream with a function, returning a new stream.
    public <R> Stream<R> fmap(Function<T, R> f) {
        // not yet implemented
        return null;
    }

    // Helper class, to create cyclic declarations, may be helpful for generating the fibonacci numbers.
    public static class CyclicRef<T> {
        public T value;
    }

    // Return the stream of all fibonacci numbers.
    public static Stream<Integer> fibS() {
        // Hint: Use CyclicRef to refer to the not yet computed sequence!
        
        // not yet implemented
        return null;
    }

    // Return the stream of all prime numbers.
    public static Stream<Integer> primeS() {
        // not yet implemented
        return null;
    }
}
